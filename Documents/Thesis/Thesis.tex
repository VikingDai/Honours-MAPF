\documentclass[a4paper,11pt]{article}

% set up sensible margins (same as for cssethesis)
\usepackage[paper=a4paper,left=30mm,right=30mm,top=25mm,bottom=25mm]{geometry}
\usepackage{natbib} % Use the natbib bibliography and citation package
\usepackage{setspace} % This is used in the title page
\usepackage{graphicx} % This is used to load the crest in the title page
\usepackage{physics} % Used for \abs

% non-template packages
\usepackage{paralist}
\usepackage{multicol}
\usepackage{caption}
\usepackage{tabularx, booktabs}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\usepackage{listings}
\lstset{
	numbers=left, 
	numberstyle=\small, 
	numbersep=8pt, 
	frame = single, 
	language=Python, 
	framexleftmargin=17pt}

\usepackage{tikz}
\usepackage{smartdiagram}

\usepackage[font={small,it}]{caption}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{lscape}
\hypersetup{
	colorlinks,
	linkcolor=teal,
	citecolor=teal,
	urlcolor=blue
}

\usepackage[english]{babel}
\usepackage{blindtext}
\usepackage{footnote}
\makesavenoteenv{tabular}
\makesavenoteenv{table}

%tikz stuff
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, trees}
\tikzstyle{decision} = [diamond, draw, fill=green!20, text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=yellow!20, text width=3cm, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{straight} = [draw]


\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage{float}

\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\floatname{algorithm}{Procedure}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\algdef{SE}[DOWHILE]{Do}{DoWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}

%\hypersetup{
%	colorlinks,
%	linkcolor={red!50!black},
%	citecolor={blue!50!black},
%	urlcolor={blue!80!black}
%}

\begin{document}
	
% Set up a title page
\thispagestyle{empty} % no page number on very first page
% Use roman numerals for page numbers initially
\renewcommand{\thepage}{\roman{page}}

\begin{spacing}{1.5}
	\begin{center}
		{\Large \bfseries
			School of Computer Science (BICA) \\
			Monash University}
		
		
		\vspace*{30mm}
		
		\includegraphics[width=5cm]{graphics/MonashCrest.pdf}
		
		\vspace*{15mm}
		
		{\large \bfseries
			Literature Review, 2017
		}
		
		\vspace*{10mm}
		
		{\LARGE \bfseries
			Review of optimal multi-agent Pathfinding algorithms and usage in warehouse automation
		}
		
		\vspace*{20mm}
		
		{\large \bfseries
			Phillip Wong
			
			\vspace*{20mm}
			
			
			Supervisors: \parbox[t]{50mm}{Daniel Harabor,\\Pierre Le Bodic}
		}
		
	\end{center}
\end{spacing}

\newpage

\tableofcontents

\newpage
% Now reset page number counter,and switch to arabic numerals for remaining
% page numbers 
\setcounter{page}{1}
\renewcommand{\thepage}{\arabic{page}}

\section{Introduction} \label{sec:introduction}

In our multi-agent pathfinding problem, we have an environment containing a set of $k$ agents on a grid-map. Each agent aims to find a path to their goal without colliding with another agent (a path collision).

Hence we have a centralized agent coordinator which aims to resolve path collisions.

\section{Related Work}
\textbf{CBS}

\textbf{ICTS}

\textbf{Centralised A*}

\textbf{That Network Flow paper}

\section{Collision-free Paths}
This section outlines the slave algorithm which is used to generate paths. These paths are then given to the Mixed Integer Program described in Section~\ref{sec:mip} which handles the assignment of paths to agents.

\subsection{Agent Coordinator}

The agent coordinator is the highest level method where paths are generated and assigned. 

\begin{algorithm}
	\caption{AgentCoordinator}\label{alg_AgentCoordinator}
	\begin{algorithmic}[1]
		\Require $\vec{a}:$ list of agents
		\Ensure $void$
		\State{$\textit{collisions} \gets \{\}$}
		\Do
			\State{$\vec{ap} \gets GeneratePaths(\vec{a})$}
			\State{$AssignPaths(\vec{ap})$}
			\State{$\textit{failedAgents} \gets \textit{AssignPaths(paths, }\vec{ap})$}
		\DoWhile{\textit{collisions is not empty()}}
	\end{algorithmic}
\end{algorithm}

\subsection{Generating Paths}
This method aims to generate paths for an agent. The first iteration of the path generation will use A* to quickly find the shortest path to the goal. This path will likely be in conflict. Next we use Temporal A* which aims to avoid collisions by applying penalties to tiles which are in conflict. This method increments the penalties by 1 and iteratively finds paths of the next cost. 

If an agent's new path has an increase in cost from the optimal path $(\Delta)$. We do not generate a path for this agent until other agents in the deadlock have the same $\Delta$. In this way we find an optimal solution as the path increments slowly?

However our implementation of Temporal A* is not complete. There are instances which it is unable to find a solution. If the optimal shortest path requires the agent to move past the goal tile. Then Temporal A* fails and will never expand past the goal. An example of this is <HERE>! Hence in this algorithm we determine that agents are in \textbf{deadlock} when they have $n=100$ number of collisions. If this occurs we start finding paths with Centralized A*. 

\begin{algorithm}[H]
	\caption{GeneratePaths}\label{alg_GeneratePaths}
	\begin{algorithmic}[1]
		\Require $\vec{a}:$ list of penalty agents $c$: counts the collisions between agents
		\Ensure $\vec{ap}$: list of paths which are in collision: a tuple of (agent, path)
		\State{$\vec{ap} \gets \{\}$}
		\For{agent $a$ in $\vec{a}$}
			\State{$path \gets \{\}$}
			\If{agent.paths is empty}
				\State{$path \gets AStar$}
			\ElsIf{$\exists$ agents in deadlock with $a$}
				\State{$path \gets CentralizedAStar(\textit{agents in deadlock})$}
			\Else
				\State{$path \gets TemporalAStar$}
			\EndIf
			\State{$path \gets \textit{GeneratePath(a, firstRun)}$}
			\State{$a.\vec{p}.append(path)$}	
			\State{$\vec{ap}.append(a, \textit{CheckCollisions(path))}$}
		\EndFor
	\end{algorithmic}
\end{algorithm}

\subsection{Path Assignment}

At the core, this method simply calls the Master problem (\ref{sec:mip}). The objective here is to detect if any agents were unable to be assigned paths (meaning there was no combination of paths which resulted in a collision-free solution). These agents are assigned the penalty variable by the mip and are returned as output of this method.

\begin{algorithm}
	\caption{AssignPaths}\label{alg_AssignPaths}
	\begin{algorithmic}[1]
		\Require $\vec{a}:$ list of agents $\vec{c}:$ list of collisions
		\Ensure $\vec{p}:$ list of agents who were assigned the penalty
		\State{$\textit{solution} \gets RunMasterProblem(\vec{a}, \vec{c})$}
		\For{$a$ in $solution.assignedAgents$}
		\State{assign collision-free path to $a$ as described by $solution$}
		\EndFor 
		\Return $solution.penaltyAgents$
	\end{algorithmic}
\end{algorithm}

\section{Resolving conflicts}
\begin{compactenum}
	\item Given a set of paths, \textit{S} which contains all agent's path, find a new path for each agent their goal and add it to \textit{S}
	\item Detect any path collision for each path
	\item Convert the paths to MIP variables and path collisions to constraints
	\item Repeat 1. if there is not a valid solution found i.e the optimal solution contains a path collision
\end{compactenum}

\section{Master problem formulation} \label{sec:mip}
Each agent is given \textit{one or more} paths to their goal. The master problem aims to assign one path to every agent while minimizing the path distance and avoiding path collisions. 

\begin{compactitem}
	\item \textbf{Potential paths}: A set of paths from an agent's position to their goal. We generate a variable for each path and the cost is set to the path length.
	\item \textbf{Penalty}: A penalty variable is added for every agent in the case that all the agent's paths are in collision. The cost of the penalty is set to be larger than the expected maximum path length (here it is 1000).
\end{compactitem}

We specify an agent's path as $p_{ij}$. Penalty $q_i$. Path collision as $c_{nm}$.

\begin{equation}
\text{min} \sum_{i \in A} \sum_{j \in P_i} (d_{ij} * p_{ij}) + q_i
\end{equation}

\begin{equation} % pick one path only
\text{subject to} \sum_{j \in P_i} (p_{ij}) + q_i = 1, \forall i \in A
\end{equation}

\begin{equation} % apply collision constraints
\sum_{m \in S_n} (p_{nm}) \le 1, \forall n \in C
\end{equation}

\begin{equation} % all vars are 1 or 0
p_{ij} \in {0, 1}, \forall i, j
\end{equation}

\begin{equation}
q_{i} \in {0, 1}, \forall i
\end{equation}

For example \cite{put example!}, our generated variables are: $5a_0p_0 + 5a_0p_1 + 1000q_0 + 2a_1p_0 + 2a_1p_1 + 1000q_1$.

Agents are assigned



\bibliographystyle{dcu}
\bibliography{bibliography}
	
\end{document}
