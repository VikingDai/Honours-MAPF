\documentclass[a4paper,11pt]{article}

% set up sensible margins (same as for cssethesis)
\usepackage[paper=a4paper,left=30mm,right=30mm,top=25mm,bottom=25mm]{geometry}
\usepackage{natbib} % Use the natbib bibliography and citation package
\usepackage{setspace} % This is used in the title page
\usepackage{graphicx} % This is used to load the crest in the title page
\usepackage{physics} % Used for \abs

% non-template packages
\usepackage{paralist}
\usepackage{multicol}
\usepackage{caption}
\usepackage{tabularx, booktabs}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\usepackage{listings}
\lstset{
	numbers=left, 
	numberstyle=\small, 
	numbersep=8pt, 
	frame = single, 
	language=Python, 
	framexleftmargin=17pt}

\usepackage{tikz}
\usepackage{smartdiagram}

\usepackage[font={small,it}]{caption}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{lscape}
\hypersetup{
	colorlinks,
	linkcolor=teal,
	citecolor=teal,
	urlcolor=blue
}

\usepackage[english]{babel}
\usepackage{blindtext}
\usepackage{footnote}
\makesavenoteenv{tabular}
\makesavenoteenv{table}

%tikz stuff
\usepackage{tikz}
\usetikzlibrary{shapes, arrows, trees}
\tikzstyle{decision} = [diamond, draw, fill=green!20, text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=yellow!20, text width=3cm, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{straight} = [draw]


\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\usepackage{float}

\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\floatname{algorithm}{Procedure}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\algdef{SE}[DOWHILE]{Do}{DoWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%
\let\oldReturn\Return
\renewcommand{\Return}{\State\oldReturn}

\usepackage{colortbl}

%\hypersetup{
%	colorlinks,
%	linkcolor={red!50!black},
%	citecolor={blue!50!black},
%	urlcolor={blue!80!black}
%}

\begin{document}
	
% Set up a title page
\thispagestyle{empty} % no page number on very first page
% Use roman numerals for page numbers initially
\renewcommand{\thepage}{\roman{page}}

\begin{spacing}{1.5}
	\begin{center}
		{\Large \bfseries
			School of Computer Science (BICA) \\
			Monash University}
		
		
		\vspace*{30mm}
		
		\includegraphics[width=5cm]{graphics/MonashCrest.pdf}
		
		\vspace*{15mm}
		
		{\large \bfseries
			Literature Review, 2017
		}
		
		\vspace*{10mm}
		
		{\LARGE \bfseries
			Review of optimal multi-agent Pathfinding algorithms and usage in warehouse automation
		}
		
		\vspace*{20mm}
		
		{\large \bfseries
			Phillip Wong
			
			\vspace*{20mm}
			
			
			Supervisors: \parbox[t]{50mm}{Daniel Harabor,\\Pierre Le Bodic}
		}
		
	\end{center}
\end{spacing}

\newpage

\tableofcontents

\newpage
% Now reset page number counter,and switch to arabic numerals for remaining
% page numbers 
\setcounter{page}{1}
\renewcommand{\thepage}{\arabic{page}}

\section{Introduction} \label{sec:introduction}

In our multi-agent pathfinding problem, we have an environment containing a set of $k$ agents on a 4 directional grid-map. Each agent aims to find a path to their goal such that no agent will collide with another agent at any time.

Hence we have a centralized agent coordinator which aims to resolve path collisions.

\subsection{Problem Overview}
\noindent \textbf{Inputs:}
\begin{itemize}
	\item Grid map
	\item Set of agents with
	\begin{itemize}
		\item Start location
		\item Goal location
	\end{itemize}
\end{itemize}

\noindent \textbf{Outputs:}
\begin{itemize}
	\item Collision free path from the start to goal location for each each agent
\end{itemize}

\begin{Large}
	INSERT IMAGE OF EXAMPLE PROBLEM
\end{Large}



\subsection{Use of Mixed Integer Programming}
\noindent \textbf{Branch and bound}

\noindent \textbf{Column generation}

\noindent \textbf{Branch and price}

\section{Related Work}
\textbf{CBS}

\textbf{ICTS}

\textbf{Centralised A*}

\textbf{That Network Flow paper}

\section{Algorithm}
Each agent knows of a number of paths to the goal. Using a Mixed Integer Program (MIP) we are able to solve the assignment problem of choosing a combination of paths such that no assigned two paths has a collision. Hence the two main parts of the algorithm:

Any specifics about the MIP I should mention here? 

\begin{compactenum}
	\item \textbf{Path Assignment} The Mixed Integer Program, Responsible for choosing a assigning paths to agents, while finding a conflict-free solution.
	\item \textbf{Path Generation:} Responsible for generating alternative paths for agents whose current paths are in collision.
\end{compactenum}

\subsection{High Level} \label{sec:high-level}
At the high-level we describe the cycle of path generation and assignment. Simply put: while the path assignment problem fails to find a solution, we run the path-generation method.

\begin{algorithm}
	\caption{high-level of the Algorithm} \label{alg:agent-coordinator}
	\begin{algorithmic}[1]
		\Require $\vec{a}:$ list of agents
		\Ensure $void$
		\State{$\textit{collisions} \gets \{\}$}
		\Do
			\State{$pathCollisions \gets GeneratePaths(\vec{a})$}
			\State{$\textit{failedAgents} \gets \textit{AssignPaths(paths, }pathCollisions)$}
			\For{$agent$ in $failedAgents$}
				\State{find path collision for $agent$ and push into $\textit{collisions}$ }
			\EndFor
		\DoWhile{\textit{collisions is not empty()}}
	\end{algorithmic}
\end{algorithm}

\subsection{Path Generation} \label{sec:generating-paths}
This method aims to generate paths for an agent. The first iteration of the path generation will use A* to quickly find the shortest path to the goal. This path will likely be in conflict. Next we use Temporal A* which aims to avoid collisions by applying penalties to tiles which are in conflict. We increments the penalties by 1 and iteratively finds paths of the next cost. 

A generated path may have a longer length than the optimal single-agent solution. Hence we describe this difference to the optimal path as $(\Delta)$. We do not generate a path for this agent until other agents in the deadlock have the same $\Delta$. In this way we find an optimal solution.

However our implementation of Temporal A* is not complete. There are instances which it is unable to find a solution. If the optimal shortest path requires the agent to move past the goal tile. Then Temporal A* fails and will never expand past the goal. An example of this is can be seen in Figure~\ref{fig:deadlock}. Hence in this algorithm we determine that agents are in \textbf{deadlock} when they have $n=100$ number of collisions. If this occurs we start finding paths with Centralized A*. 


\begin{table}
	\centering
	\footnotesize
	\begin{tabular}{|c|c|c|}
		\hline
		$a1$ & \cellcolor{black} & \\ \hline
		$t2$ & & $t1$ \\ \hline
		& \cellcolor{black} & $a2$ \\ \hline
	\end{tabular}

	\caption{A deadlock occurs here. The optimal solution is 
		\\ a1: $d,r,r,u,d,w$
		\\ a2: $w,w,w,u,l,l$
		\\ This deadlock occurs as the solution for a1 requires the algorithm to seach past the goal.}
	\label{fig:deadlock}
\end{table}


\begin{algorithm}[H]
	\caption{GeneratePaths}\label{alg:generate-paths}
	\begin{algorithmic}[1]
		\Require $\vec{a}:$ list of penalty agents
		\Ensure $pathCollisions$: list of paths which are in collision: a tuple of (agent, path)
		\State{$pathCollisions \gets \{\}$}
		\For{agent $a$ in $\vec{a}$}
			\State{$path \gets \{\}$}
			\If{agent.paths is empty}
				\State{$path \gets AStar$}
			\ElsIf{$\exists$ agents in deadlock with $a$}
				\State{$path \gets CentralizedAStar(\textit{agents in deadlock})$}
			\Else
				\State{$path \gets TemporalAStar$}
			\EndIf
			\State{$path \gets \textit{GeneratePath(a, firstRun)}$}
			\State{$a.\vec{p}.append(path)$}	
			\State{$pathCollisions.append(a, \textit{CheckCollisions(path))}$}
		\EndFor
	\end{algorithmic}
\end{algorithm}

\subsection{Path Assignment}
At the core, this method simply calls the Master problem (\ref{sec:mip}). The objective here is to detect if any agents were unable to be assigned paths (meaning there was no combination of paths which resulted in a collision-free solution). These agents are assigned the penalty variable by the mip and are returned as output of this method.

\begin{algorithm}
	\caption{AssignPaths}\label{alg:assignPaths}
	\begin{algorithmic}[1]
		\Require $\vec{a}:$ list of agents $\vec{c}:$ list of collisions
		\Ensure $\vec{p}:$ list of agents who were assigned the penalty
		\State{$\textit{solution} \gets RunMasterProblem(\vec{a}, \vec{c})$}
		\For{$a$ in $solution.assignedAgents$}
		\State{assign collision-free path to $a$ as described by $solution$}
		\EndFor 
		\Return $solution.penaltyAgents$
	\end{algorithmic}
\end{algorithm}

\subsection{Temporal A* with collision penalties} \label{sec:temporalastar}
Here we describe our time-expanded A* implementation. The goal of this algorithm is to incrementally find paths of increasing cost to ensure optimality. We do this applying a penalty to tiles when collisions occur. Collision detection is described in Section~\ref{sec:generating-paths}.

\begin{algorithm}
	\caption{Temporal A* Node} \label{alg:temporalastar-node}
	\begin{algorithmic}[1]
		\Require $parent$, $tile$, $goal$, $penalty$
		\Ensure $Node$: a new Temporal A* Node
		\State{$h \gets Heuristic(tile, goal)$}
		\If{$parent$ is $null$}
			\State{$time \gets 0$}
			\State{$g \gets 0$}
		\Else
			\State{$time \gets parent.time + 1$}
			\State{$g \gets parent.cost + 1$}
		\EndIf
		\State{$f \gets g + h + penalty$}
		\Return $this$
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Temporal A* comparator} \label{alg:temporalastarheur}
	\begin{algorithmic}[1]
		\Require node $a$, node $b$
		\Ensure $bool$
		\If{$a.f$ equals $b.f$}
			\If{$a.penalty$ equals $b.penalty$}
				\Return $a.g < b.g$
			\Else
				\Return $a.penalty < b.penalty$
			\EndIf
		\Else
			\Return $a.f < b.f$
		\EndIf
	\end{algorithmic}
\end{algorithm}

The temporal A* algorithm aims to find a path from start to goal. Additionally our variant takes in a set of collision penalties. A collision penalty describes that the agent should try to avoid moving from tile $a$ to tile $b$ at timestep $t$. The collision penalty is used to calculate the $f$ value for each node and determines the priority for expansion.

\begin{algorithm}
	\caption{Temporal A* with collision penalties} \label{alg:temporalastar}
	\begin{algorithmic}[1]
		\Require $s:$ start, $g:$ goal, $\vec{c}:$ penalties, a vector of collision penalties
		\Ensure $p:$ path
		\State{$path \gets \{\}$}
		\If{$s$ or $g$ is not valid or $s$ equals $g$}
			\Return $path$
		\EndIf
		\State{$open \gets PriorityQueue<Node>()$}
		\State{push $Node(null, s, g, 0)$ into $open$}
		\While{$open$ is not empty}
			\State{$current \gets open.pop()$}
			\For{$action$ in $\{up, down, left, right, wait\}$}
				\State{$nextTile \gets$ perform $action$ on $current$}
				\If{$\exists node$ at time $current.time + 1$ on tile $nextTile$}
					\State{update $node$ by comparing $node.parent$ and $current$, taking the lowest $f$}
				\Else
					\State{penalty $\gets penalties[current.time + 1][current.tile][nextTile]$}
					\State{$newNode \gets Node(current, nextTile, g, penalty)$}
				\EndIf
			\EndFor
		\EndWhile
		
		\While{$current$ is not $null$}
			\State{add $current$ to the front of $path$}
			\State{$current \gets current.parent$}
		\EndWhile
		\Return $path$
	\end{algorithmic}
\end{algorithm}

struct \{\}

\section{Resolving conflicts}
\begin{compactenum}
	\item Given a set of paths, \textit{S} which contains all agent's path, find a new path for each agent their goal and add it to \textit{S}
	\item Detect any path collision for each path
	\item Convert the paths to MIP variables and path collisions to constraints
	\item Repeat 1. if there is not a valid solution found i.e the optimal solution contains a path collision
\end{compactenum}

\section{Master problem formulation} \label{sec:mip}

Each agent is given \textit{one or more} paths to their goal. The master problem aims to assign one path to every agent while minimizing the path distance and avoiding path collisions. 

\begin{itemize}
	\item \textbf{Agents:} The MIP is given a set of agents, $A$
	\item \textbf{Potential paths}: Every agent has a set of paths, $P$ describing a unique path from an agent's position to their goal.
	\item \textbf{Penalty}: A penalty variable, $q_i$ is added for every agent in the case that all the agent's paths are in collision. If the MIP chooses this penalty in the solution, then the MIP was unable to find an assignment of paths which resulted in a conflict-free solution. The cost of the penalty is set to be larger than the expected maximum path length (here it is 1000).
	\item \textbf{Conflicts:} A set of conflicts, $C$ is provided to the MIP. A conflict is a set of paths, describing that these paths are not allowed to be assigned at the same time as they will cause a conflict. 
\end{itemize}

We generate a variable for each path and the cost is set to the path length.

We specify an agent's path as $p_{ij}$. Penalty $q_i$. Path collision as $c_{nm}$.



\begin{equation} \label{mas:min}
\text{min} \sum_{i \in A} \sum_{j \in P_i} (d_{ij} * p_{ij}) + q_i
\end{equation}

\begin{equation} \label{mas:pick} % pick one path only
\text{subject to} \sum_{j \in P_i} (p_{ij}) + q_i = 1, \forall i \in A
\end{equation}

\begin{equation} \label{mas:conflict} % apply collision constraints
\sum_{m \in P_c} p_{cm} \le 1, \forall c \in C
\end{equation}

\begin{equation} \label{mas:path-one-or-zero} % all vars are 1 or 0
p_{ij} \in {0, 1}, \forall i, j
\end{equation}

\begin{equation} \label{mas:penalty} % penalty is 1 or 0
q_{i} \in {0, 1}, \forall i
\end{equation}

For example \cite{put example!}, our generated variables are: $5a_0p_0 + 5a_0p_1 + 1000q_0 + 2a_1p_0 + 2a_1p_1 + 1000q_1$.

Agents are assigned



\bibliographystyle{dcu}
\bibliography{bibliography}
	
\end{document}
